// Code generated by protoc-gen-go. DO NOT EDIT.
// source: musiclib.proto

package mlibgrpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type BrowseType int32

const (
	BrowseType_BROWSE_TYPE_UNSPECIFIED  BrowseType = 0
	BrowseType_BROWSE_TYPE_FOLDER       BrowseType = 1
	BrowseType_BROWSE_TYPE_ALBUM_ARTIST BrowseType = 2
)

var BrowseType_name = map[int32]string{
	0: "BROWSE_TYPE_UNSPECIFIED",
	1: "BROWSE_TYPE_FOLDER",
	2: "BROWSE_TYPE_ALBUM_ARTIST",
}

var BrowseType_value = map[string]int32{
	"BROWSE_TYPE_UNSPECIFIED":  0,
	"BROWSE_TYPE_FOLDER":       1,
	"BROWSE_TYPE_ALBUM_ARTIST": 2,
}

func (x BrowseType) String() string {
	return proto.EnumName(BrowseType_name, int32(x))
}

func (BrowseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a6d90c975a0c672, []int{0}
}

type BrowseRequest struct {
	Uri                  string     `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Search               string     `protobuf:"bytes,2,opt,name=search,proto3" json:"search,omitempty"`
	Reverse              bool       `protobuf:"varint,3,opt,name=reverse,proto3" json:"reverse,omitempty"`
	BrowseType           BrowseType `protobuf:"varint,4,opt,name=browse_type,json=browseType,proto3,enum=mlibgrpc.BrowseType" json:"browse_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BrowseRequest) Reset()         { *m = BrowseRequest{} }
func (m *BrowseRequest) String() string { return proto.CompactTextString(m) }
func (*BrowseRequest) ProtoMessage()    {}
func (*BrowseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a6d90c975a0c672, []int{0}
}

func (m *BrowseRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BrowseRequest.Unmarshal(m, b)
}
func (m *BrowseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BrowseRequest.Marshal(b, m, deterministic)
}
func (m *BrowseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BrowseRequest.Merge(m, src)
}
func (m *BrowseRequest) XXX_Size() int {
	return xxx_messageInfo_BrowseRequest.Size(m)
}
func (m *BrowseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BrowseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BrowseRequest proto.InternalMessageInfo

func (m *BrowseRequest) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *BrowseRequest) GetSearch() string {
	if m != nil {
		return m.Search
	}
	return ""
}

func (m *BrowseRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

func (m *BrowseRequest) GetBrowseType() BrowseType {
	if m != nil {
		return m.BrowseType
	}
	return BrowseType_BROWSE_TYPE_UNSPECIFIED
}

type BrowseResponse struct {
	Items                []*BrowseItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BrowseResponse) Reset()         { *m = BrowseResponse{} }
func (m *BrowseResponse) String() string { return proto.CompactTextString(m) }
func (*BrowseResponse) ProtoMessage()    {}
func (*BrowseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a6d90c975a0c672, []int{1}
}

func (m *BrowseResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BrowseResponse.Unmarshal(m, b)
}
func (m *BrowseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BrowseResponse.Marshal(b, m, deterministic)
}
func (m *BrowseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BrowseResponse.Merge(m, src)
}
func (m *BrowseResponse) XXX_Size() int {
	return xxx_messageInfo_BrowseResponse.Size(m)
}
func (m *BrowseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BrowseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BrowseResponse proto.InternalMessageInfo

func (m *BrowseResponse) GetItems() []*BrowseItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type BrowseItem struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Uri                  string   `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	Folder               bool     `protobuf:"varint,3,opt,name=folder,proto3" json:"folder,omitempty"`
	ImageUri             string   `protobuf:"bytes,4,opt,name=image_uri,json=imageUri,proto3" json:"image_uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BrowseItem) Reset()         { *m = BrowseItem{} }
func (m *BrowseItem) String() string { return proto.CompactTextString(m) }
func (*BrowseItem) ProtoMessage()    {}
func (*BrowseItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a6d90c975a0c672, []int{2}
}

func (m *BrowseItem) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BrowseItem.Unmarshal(m, b)
}
func (m *BrowseItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BrowseItem.Marshal(b, m, deterministic)
}
func (m *BrowseItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BrowseItem.Merge(m, src)
}
func (m *BrowseItem) XXX_Size() int {
	return xxx_messageInfo_BrowseItem.Size(m)
}
func (m *BrowseItem) XXX_DiscardUnknown() {
	xxx_messageInfo_BrowseItem.DiscardUnknown(m)
}

var xxx_messageInfo_BrowseItem proto.InternalMessageInfo

func (m *BrowseItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BrowseItem) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *BrowseItem) GetFolder() bool {
	if m != nil {
		return m.Folder
	}
	return false
}

func (m *BrowseItem) GetImageUri() string {
	if m != nil {
		return m.ImageUri
	}
	return ""
}

type MediaRequest struct {
	Uri                  string     `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Search               string     `protobuf:"bytes,2,opt,name=search,proto3" json:"search,omitempty"`
	Reverse              bool       `protobuf:"varint,3,opt,name=reverse,proto3" json:"reverse,omitempty"`
	BrowseType           BrowseType `protobuf:"varint,4,opt,name=browse_type,json=browseType,proto3,enum=mlibgrpc.BrowseType" json:"browse_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MediaRequest) Reset()         { *m = MediaRequest{} }
func (m *MediaRequest) String() string { return proto.CompactTextString(m) }
func (*MediaRequest) ProtoMessage()    {}
func (*MediaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a6d90c975a0c672, []int{3}
}

func (m *MediaRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MediaRequest.Unmarshal(m, b)
}
func (m *MediaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MediaRequest.Marshal(b, m, deterministic)
}
func (m *MediaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaRequest.Merge(m, src)
}
func (m *MediaRequest) XXX_Size() int {
	return xxx_messageInfo_MediaRequest.Size(m)
}
func (m *MediaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MediaRequest proto.InternalMessageInfo

func (m *MediaRequest) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *MediaRequest) GetSearch() string {
	if m != nil {
		return m.Search
	}
	return ""
}

func (m *MediaRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

func (m *MediaRequest) GetBrowseType() BrowseType {
	if m != nil {
		return m.BrowseType
	}
	return BrowseType_BROWSE_TYPE_UNSPECIFIED
}

type MediaResponse struct {
	Uris                 []string `protobuf:"bytes,1,rep,name=uris,proto3" json:"uris,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MediaResponse) Reset()         { *m = MediaResponse{} }
func (m *MediaResponse) String() string { return proto.CompactTextString(m) }
func (*MediaResponse) ProtoMessage()    {}
func (*MediaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a6d90c975a0c672, []int{4}
}

func (m *MediaResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MediaResponse.Unmarshal(m, b)
}
func (m *MediaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MediaResponse.Marshal(b, m, deterministic)
}
func (m *MediaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MediaResponse.Merge(m, src)
}
func (m *MediaResponse) XXX_Size() int {
	return xxx_messageInfo_MediaResponse.Size(m)
}
func (m *MediaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MediaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MediaResponse proto.InternalMessageInfo

func (m *MediaResponse) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func init() {
	proto.RegisterEnum("mlibgrpc.BrowseType", BrowseType_name, BrowseType_value)
	proto.RegisterType((*BrowseRequest)(nil), "mlibgrpc.BrowseRequest")
	proto.RegisterType((*BrowseResponse)(nil), "mlibgrpc.BrowseResponse")
	proto.RegisterType((*BrowseItem)(nil), "mlibgrpc.BrowseItem")
	proto.RegisterType((*MediaRequest)(nil), "mlibgrpc.MediaRequest")
	proto.RegisterType((*MediaResponse)(nil), "mlibgrpc.MediaResponse")
}

func init() {
	proto.RegisterFile("musiclib.proto", fileDescriptor_7a6d90c975a0c672)
}

var fileDescriptor_7a6d90c975a0c672 = []byte{
	// 388 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x52, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0xed, 0x26, 0x6e, 0x48, 0xa6, 0x34, 0xb2, 0x46, 0x28, 0x59, 0xb5, 0x1c, 0x2c, 0x73, 0xb1,
	0x7a, 0xc8, 0xa1, 0x88, 0x0b, 0x82, 0x43, 0x43, 0x5d, 0xc9, 0x52, 0x4a, 0xa3, 0x8d, 0x23, 0xc4,
	0xc9, 0xb2, 0x93, 0x21, 0xac, 0x14, 0xc7, 0x66, 0xd7, 0x06, 0xe5, 0x13, 0xe0, 0xab, 0x91, 0xd7,
	0x36, 0x09, 0xe4, 0x07, 0xb8, 0xbd, 0x79, 0xfb, 0x76, 0x66, 0xde, 0xd3, 0xc0, 0x30, 0x2d, 0xb5,
	0x5c, 0x6d, 0x65, 0x32, 0xc9, 0x55, 0x56, 0x64, 0xd8, 0x4f, 0xb7, 0x32, 0xd9, 0xa8, 0x7c, 0xe5,
	0xfe, 0x62, 0x70, 0x39, 0x55, 0xd9, 0x0f, 0x4d, 0x82, 0xbe, 0x95, 0xa4, 0x0b, 0xb4, 0xa1, 0x5b,
	0x2a, 0xc9, 0x99, 0xc3, 0xbc, 0x81, 0xa8, 0x20, 0x8e, 0xa0, 0xa7, 0x29, 0x56, 0xab, 0xaf, 0xbc,
	0x63, 0xc8, 0xa6, 0x42, 0x0e, 0xcf, 0x14, 0x7d, 0x27, 0xa5, 0x89, 0x77, 0x1d, 0xe6, 0xf5, 0x45,
	0x5b, 0xe2, 0x1b, 0xb8, 0x48, 0x4c, 0xd3, 0xa8, 0xd8, 0xe7, 0xc4, 0x2d, 0x87, 0x79, 0xc3, 0xdb,
	0x17, 0x93, 0x76, 0xea, 0xa4, 0x9e, 0x18, 0xee, 0x73, 0x12, 0x90, 0xfc, 0xc1, 0xee, 0x3b, 0x18,
	0xb6, 0xbb, 0xe8, 0x3c, 0xdb, 0x69, 0xc2, 0x1b, 0x38, 0x97, 0x05, 0xa5, 0x9a, 0x33, 0xa7, 0xeb,
	0x5d, 0x9c, 0xb6, 0x08, 0x0a, 0x4a, 0x45, 0x2d, 0x71, 0x37, 0x00, 0x07, 0x12, 0x11, 0xac, 0x5d,
	0x9c, 0x52, 0xe3, 0xc3, 0xe0, 0xd6, 0x5a, 0xe7, 0x2f, 0x6b, 0x5f, 0xb2, 0xed, 0x9a, 0x54, 0xe3,
	0xa0, 0xa9, 0xf0, 0x1a, 0x06, 0x32, 0x8d, 0x37, 0x14, 0x55, 0x7a, 0xcb, 0xe8, 0xfb, 0x86, 0x58,
	0x2a, 0xe9, 0xfe, 0x64, 0xf0, 0xfc, 0x91, 0xd6, 0x32, 0xfe, 0x0f, 0x22, 0x7b, 0x05, 0x97, 0xcd,
	0x2a, 0x4d, 0x62, 0x08, 0x56, 0xa9, 0x64, 0x1d, 0xd8, 0x40, 0x18, 0x7c, 0x13, 0xb5, 0xc9, 0x54,
	0x5f, 0xf0, 0x1a, 0xc6, 0x53, 0xf1, 0xf4, 0x69, 0xe1, 0x47, 0xe1, 0xe7, 0xb9, 0x1f, 0x2d, 0x3f,
	0x2e, 0xe6, 0xfe, 0x87, 0xe0, 0x21, 0xf0, 0xef, 0xed, 0x33, 0x1c, 0x01, 0x1e, 0x3f, 0x3e, 0x3c,
	0xcd, 0xee, 0x7d, 0x61, 0x33, 0x7c, 0x09, 0xfc, 0x98, 0xbf, 0x9b, 0x4d, 0x97, 0x8f, 0xd1, 0x9d,
	0x08, 0x83, 0x45, 0x68, 0x77, 0x6e, 0x4d, 0x22, 0xd5, 0x89, 0xcd, 0x64, 0xa2, 0x62, 0xb5, 0xc7,
	0xf7, 0xd0, 0xab, 0x27, 0xe2, 0xf8, 0x5f, 0x0b, 0x4d, 0x68, 0x57, 0xfc, 0xf4, 0xa1, 0xb6, 0xe0,
	0x9e, 0xe1, 0x5b, 0x38, 0x37, 0xae, 0x70, 0x74, 0x10, 0x1d, 0x27, 0x7e, 0x35, 0x3e, 0xe1, 0xdb,
	0xbf, 0x49, 0xcf, 0x9c, 0xf8, 0xeb, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x70, 0x60, 0xea, 0x1b,
	0xf4, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// MusicLibraryClient is the client API for MusicLibrary service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MusicLibraryClient interface {
	// Browse returns matching contents of a folder uri
	Browse(ctx context.Context, in *BrowseRequest, opts ...grpc.CallOption) (*BrowseResponse, error)
	// Media resolves a folder uri to a list of descendant media uris
	Media(ctx context.Context, in *MediaRequest, opts ...grpc.CallOption) (*MediaResponse, error)
}

type musicLibraryClient struct {
	cc grpc.ClientConnInterface
}

func NewMusicLibraryClient(cc grpc.ClientConnInterface) MusicLibraryClient {
	return &musicLibraryClient{cc}
}

func (c *musicLibraryClient) Browse(ctx context.Context, in *BrowseRequest, opts ...grpc.CallOption) (*BrowseResponse, error) {
	out := new(BrowseResponse)
	err := c.cc.Invoke(ctx, "/mlibgrpc.MusicLibrary/Browse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *musicLibraryClient) Media(ctx context.Context, in *MediaRequest, opts ...grpc.CallOption) (*MediaResponse, error) {
	out := new(MediaResponse)
	err := c.cc.Invoke(ctx, "/mlibgrpc.MusicLibrary/Media", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MusicLibraryServer is the server API for MusicLibrary service.
type MusicLibraryServer interface {
	// Browse returns matching contents of a folder uri
	Browse(context.Context, *BrowseRequest) (*BrowseResponse, error)
	// Media resolves a folder uri to a list of descendant media uris
	Media(context.Context, *MediaRequest) (*MediaResponse, error)
}

// UnimplementedMusicLibraryServer can be embedded to have forward compatible implementations.
type UnimplementedMusicLibraryServer struct {
}

func (*UnimplementedMusicLibraryServer) Browse(ctx context.Context, req *BrowseRequest) (*BrowseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Browse not implemented")
}
func (*UnimplementedMusicLibraryServer) Media(ctx context.Context, req *MediaRequest) (*MediaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Media not implemented")
}

func RegisterMusicLibraryServer(s *grpc.Server, srv MusicLibraryServer) {
	s.RegisterService(&_MusicLibrary_serviceDesc, srv)
}

func _MusicLibrary_Browse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BrowseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MusicLibraryServer).Browse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlibgrpc.MusicLibrary/Browse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MusicLibraryServer).Browse(ctx, req.(*BrowseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MusicLibrary_Media_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MediaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MusicLibraryServer).Media(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mlibgrpc.MusicLibrary/Media",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MusicLibraryServer).Media(ctx, req.(*MediaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MusicLibrary_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mlibgrpc.MusicLibrary",
	HandlerType: (*MusicLibraryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Browse",
			Handler:    _MusicLibrary_Browse_Handler,
		},
		{
			MethodName: "Media",
			Handler:    _MusicLibrary_Media_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "musiclib.proto",
}
